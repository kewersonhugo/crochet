%[
open Fable.Core
open Crochet.VM.Syntax.AST

[<Emit("Number($0)")>]
let parseNumber s : double = jsNative

[<Emit("BigInt($0)")>]
let parseInt s : bigint = jsNative

[<Emit("JSON.parse($0)")>]
let parseJson s : string = jsNative

let parseString (s:string) =
  parseJson ((s.Replace("\r\n", "\\n")).Replace("\n", "\\n"))

let escaped (s:string) =
  parseString ("\"" + s.Replace("\"", "\\\"") + "\"")

let fixNumber (s:string) = s.Replace("_", "")
]%

Crochet : Program {
  program =
    | header ds:declarations space* end
      %[ program ds ]%


  // -- Declarations
  declarations =
    | xs:listOf<declaration, s<";">> s<";">?    %[ xs ]%

  declaration =
    | actorDeclaration
    | relationDeclaration
    | actionDeclaration
    | beforeDeclaration
    | afterDeclaration
    | doDeclaration

  actorDeclaration =
    | actor_ n:actorName
      %[ DActor n ]%

  relationDeclaration =
    | relation_ s:logicSignature<relationPart>
      %[ DRelation s ]%

  relationPart =
    | n:name s<"*">
      %[ RPTMany n ]%
    | n:name
      %[ RPTOne n ]%

  actionDeclaration =
    | action_ t:interpolateText<name> when_ p:predicate b:statementBlock<logicStmt>
      %[ DAction(t, p, b) ]%
    
  beforeDeclaration =
    | before_ p:predicate b:statementBlock<logicStmt>
      %[ DBefore(p, b) ]%

  afterDeclaration =
    | after_ p:predicate b:statementBlock<logicStmt>
      %[ DAfter(p, b) ]%

  doDeclaration =
    | do_ xs:statementBlock<logicStmt>
      %[ DDo xs ]%


  // -- More logic
  predicate =
    | cs:nonemptyLisOf<clause, s<",">> if_ c:constraint
      %[ predicate cs c ]%
    | cs:nonemptyListOf<clause, s<",">>
      %[ predicate cs (CLiteral LTrue) ]%

  constraint =
    | l:constraint op:constraintOp r:constraint
      %[ CBinOp (op, l, r) ]%
    | not_ l:constraint
      %[ CNot l ]%
    | n:name
      %[ CVariable n ]%
    | l:literal
      %[ CLiteral l ]%

  constraint_op =
    | and_        %[ OpAnd ]%
    | or_         %[ OpOr ]%
    | s<"===">    %[ OpEq ]%
    | s<"=/=">    %[ OpNotEq ]%
    | s<">">      %[ OpGt ]%
    | s<">=">     %[ OpGte ]%
    | s<"<">      %[ OpLt ]%
    | s<"<=">     %[ OpLte ]%


  // -- Statements
  statement =
    | letStatement
    | e:expression    %[ SExpression e ]%

  logicStmt =
    | factStatement
    | forgetStatement
    | statement
  
  letStatement =
    | let_ n:name s<"="> e:expression
      %[ SLet (n, e) ]%
  
  factStatement =
    | fact_ f:logicSignature<expression>
      %[ SFact f ]%

  forgetStatement =
    | forget_ f:logicSignature<expression>
      %[ SForget f ]%


  // -- Expressions
  expression =
    | primaryExpression

  primaryExpression =
    | n:actor_name          %[ EActor n ]%
    | l:literal             %[ ELiteral l ]%
    | "(" e:expression ")"  %[ e ]%

  literal =
    | integer | text | nothing | true

  // -- Primitives
  integer = x:t_integer   %[ LInteger x ]%
  text = x:t_text         %[ LText x ]%
  true = true_            %[ LTrue ]%
  nothing = nothing_      %[ LFalse ]%
  actor_name = t_actor_name


  // -- Higher-Order
  statementBlock<typ> =
    | s<"{"> xs:listOf<type, s<";">> s<";">? s<"}">
      %[ xs ]%

  logicSignature<t> =
    | s:t kws:logicSignaturePair<t>+
      %[ LSKeyword (s, kws) ]%
    | s:t n:atom
      %[ LSUnary (s, n) ]%
  
  logicSignaturePair<t> =
    | kw:keyword p:t
      %[ (kw, p) ]%

  s<p> = space* p


  // -- Interpolation
  interpolateTextPart<p> =
    | "\\" x:any                 %[ TPStatic (escaped x) ]%
    | "[" x:s<p> s<"]">          %[ TPDynamic x ]%
    | ~"\"" x:any                %[ TPStatic x ]%

  interpolateText<p> (a text with interpolation) =
    | s<"\""> interpolateTextPart<p>* "\""

  // -- Lexical rules -------------------------------------------------
  header (a file header) = "%" hs* "crochet" nl
  hs = " " | "\t"
  nl = "\n" | "\r"
  line = (~nl any)*
  comment (a comment) = "//" line
  space += comment

  atom_start = "a".."z"
  atom_rest = letter | digit | "-"
  t_atom (an atom) = atom_start atom_rest*

  t_keyword (a keyword) = t_atom ":"

  t_actor_name (an actor name) = "#" t_atom

  name_start = "A".."Z" | "_"
  name_rest = letter | digit | "-"
  t_name (a name) = name_start name_rest*

  t_infix_symbol =
    | "+" | "-" | "*" | "/"
    | "<" | ">" | "<=" | ">="
    | "===" | "=/="

  dec_digit = "0".."9" | "_"

  t_integer = x:t_integer_b %[ parseInt (fixNumber x) ]%
  t_integer_b (an integer) =
    | ~"_" dec_digit+

  t_float = x:t_float_b %[ parseNumber (fixNumber x) ]%
  t_float_b (a floating-point number) =
    | ~"_" dec_digit+ "." dec_digit+

  text_character =
    | "\\" "\""
    | ~"\"" any

  t_text = x:t_text_b %[ parseString x ]%
  t_text_b (a text) =
    | "\"" text_character* "\""

  kw<word> = s<word> ~atom_rest

  true_ = kw<"true">
  false_ = kw<"false">
  nothing_ = kw<"nothing">
  scene_ = kw<"scene">
  command_ = kw<"command">
  do_ = kw<"do">
  return_ = kw<"return">
  goto_ = kw<"goto">
  let_ = kw<"let">
  end_ = kw<"end">
  actor_ = kw<"actor">
  relation_ = kw<"relation">
  fact_ = kw<"fact">
  forget_ = kw<"forget">
  search_ = kw<"search">
  action_ = kw<"action">
  when_ = kw<"when">
  choose_ = kw<"choose">
  if_ = kw<"if">
  and_ = kw<"and">
  or_ = kw<"or">
  not_ = kw<"not">
  context_ = kw<"context">
  trigger_ = kw<"trigger">
  then_ = kw<"then">
  else_ = kw<"else">
  match_ = kw<"match">
  repeatable_ = kw<"repeatable">

  reserved =
    | true_ | false_ | nothing_ 
    | scene_ | command_ | do_ | return_ | goto_ | let_ | end_
    | actor_ | relation_ | fact_ | search_ | forget_ | action_
    | when_ | choose_ | if_ | and_ | or_ | not_ | context_ | trigger_
    | then_ | else_ | match_ | repeatable_
}